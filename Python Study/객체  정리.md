## 객체지향 프로그래밍

- 객체
  - 객체는 특정타입의 인스턴스
    - ex) 000, 135는 int의 인스턴스
  - 숫자는 특정 클래스의 인스턴스다
  - 숫자는 하나하나의 객체이다 그래서 인스턴스는 객체이다. (문자, 리스트 동일)
- 속성 : 객체의 상태, 데이터

- 메서드 : 특정 객체에 적용될 수 있는 행위, 즉 함수이다.

  ```python
  [4,5,6].pop() # -> [4,5,6]은 인스턴스, .pop()은 메서드
  
  abc = Person('도훈', '남')
  abc.greeting()
  # abc는 인스턴스
  # greeting 메서드
  ```



- is : 객체의 아이덴티티를 검사하는 연산자

```python
type(3) is int 
# True

type(0) is bool
# False

type(20) is object
# False
```



- isinstance(객체, 클래스)
  - 클래스의 인스턴스이거나 서브클래스이면 True
  - 클래스가 튜플일 경우 하나라도 만족하면 True
  - 클래스가 type이거나 type으로 구성되지 않으면 Error발생

```python
isinsatance(3, int)
# True

isinstance(0, (bool, int, complex))
# True
```



- 프로그래밍 패러다임 : 기능에 따라 프로그래밍 언어를 분류
  1. 명령형 프로그래밍(방법을 프로그래머가 제시)
     1. 절차 지향 프로그래밍
     2. 객체 지향 프로그래밍
  2. 선언형 프로그래밍



```python
a = 1
b = 2

# a,b는 객체다.
# a,b는 int class의 인스턴스다.
```



- 사각형
  - 사각형의 정보 - 객체 속성 -> ex) 가로길이, 세로길이
  - 사각형의 행동 - 객체 메서드 -> ex) 넓이 , 높이
  - 인스턴스.메서드, 인스턴스.속성 으로 접근
  
  ```python
  # 클래스 정의
  class MyPython:
  # 인스턴스 생성 
  my_instance = MyPython()
  # 메서드 호출
  my_instance.method()
  # 속성
  my_instance.attribute()
  ```
  
  

- 속성 : 데이터 타입 / 클래스의 객체들이 가지게 될 상태 및 데이터

  ```python
  class Car:
      def __init__(self, name):
          self.name = name
          
  car1 = Car('현대')
  car1.name
  ```

-  메서드 : 데이터 타입과 클래스의 객체에 공통적으로 적용 가능한 함수

  ```python
  class Car:
      def ride(self):
          print("달려")
      
      def people(self, num):
          print(f'{num}명이 타고 있다.')
          
  car1 = Car()
  car1.ride()
  car1.people(3)
  ```

  

- Self : 인스턴스 자기자신, 호출시 첫번째 인자로 인스턴스 자신

  Self가 있다 -> 인스턴스 메서드다

  ```python
  'car'.capitalize() # 우리가 쓰는것 (축약형)
  str.capitalize('apple') # 실제 동작
  ```

  

- 생성자 : 인스턴스 객체가 생성될 때 호출되는 메서드

- 소멸자 : 인스턴스 객체가 소멸되기 전에 호출되는 메서드

- 매직메서드 : 특수한 동작을 위해 만들어진 메서드
  - \__str__ : 해당 객체의 출력 형태 지정
  - \__gt__ : 부등호 연산자





- 메서드에서 self.<이름>으로 정의

  ```python
  class Car:
      # 인스턴스 변수 : 인스턴스 속성
      def __init__(self, name):
          self.name = namse # 인스턴스 변수를 정의
          
  sportscar = Car("sports")
  print(sportscar.name) # 인스턴스 변수 접근
  ```

  

- 클래스 변수
  - 클래스 속성, 모든 인스턴스가 공유
  - 클래스 선언 내부에서 정의
  - <클래스이름><이름>으로 접근

  - 인스턴스 자기자신에서 찾고 없으면 클래스로 , 다음은 전역을 찾는다.



- 기타
  - 클래스를 정의하면 클래스와 해당하는 이름공간 생성
  - 인스턴스를 만들면 인스턴스 객체가 생성되고 이름공간 생성
  - 인스턴스에서 속성에 접근하면 인스턴스-클래스 순으로 탐색
  - 클래스에서 인스턴스 변수로 접근 불가능



### 메서드 종류

- 인스턴스 메서드 : 

  - 인스턴스가 사용할 메서드 
  - 메서드 기본, 호출시 자기자신(self) 가 전달됨
  - self 매개변수를 통해 동일한 객체에 정의된 속성 및 다른 메서드에 자유롭게 접근 가능

  ```python
  class Car:
      def instance_method(self, ex1, ..):
          
  ex_car = Car()
  ex_car.instance_method()
  ```

- 클래스 메서드 - 클래스가 사용할 메서드
  - @classmethod 데코레이터 사용
  - 호출시 첫번째 인자로 클래스가 전달
  - cls인자만 접근할 수 있기 때문에 객체 인스턴스 상태를 수정할수는 없다

  ```python
  class MyCar:
      @classmethod
      def class_method(cls, args1):
  ```

  

- 스태틱 메서드
  - 클래스가 사용할 메서드
  - @staticmethod 데코레이터 사용
  - 호출 시 self와 cls가 전달되지 않음 (클래스 정보에 접근이 불가)
  - 임의 개수의 매개 변수를 받을 수 있지만, cls 매개변수는 사용할 수 없다.
  - 객체 상태나 클래스 상태 수정 불가
  - 일반 함수처럼 동작하지만 클래스의 이름공간에 귀속, 주로 해당 클래스로 한정하는 용도



- 클래스변수와 인스턴스 함수의 함정
  - 클래스 변수는 모든 클래스 인스턴스에서 공유하는 데이터를 위한 변수
  - 인스턴스 변수는 각 인스턴스에 고유한 데이터를 위한 것
  - 클래스 변수는 동일한 이름의 인스턴스 변수에 의해 가려질 수 있기 때문에 주의



- 클래스 기타
  - == (동등한) : 두 객체가 같아 보이지만 실제로 동일한 대상을 가리키고 있다고 확인한건 아님
  - is(동일한) : 두 변수가 동일한 객체를 가리키는 경우



- 스태틱 메서드는 언제 사용해야 할까
  - self, cls 인자를 취하지 않아서 사용에 큰 제약이 있을 것 같다 -> 메서드 주변의 다른것들과 독립적일 수 있다.

  - 스태틱 메서드와 클래스 메서드는 개발자의 의도를 전달하는 동시에  개발자가 자신의 의도를 강제해 버그로 인해 설계를 깨뜨리지 않도록 함
  - self, cls 인자를 전달하지 않아서 객체 인스턴스, 클래스 상태에 접근할 수 없는걸 보장한다,
  - 일반함수 사용하는 것 처럼 실행하기 때문에 객체지향과 절차지향 스타일 사이를 연결하는 역할



### 상속

- 상속
  - 클래스는 상속이 가능
  - 상속을 통해 객체 간의 관계를 구축 가능
  - 상속을 통해 재사용성이 높아짐
  - 상속받은것은 isinstance가 True값이 나온다.



- issubclass(클래스, classinfo)
  - 클래스가 classinfo의 subclass면 True

  - info는 객체의 튜플일 수 있다.

  ```python
  issubclass(bool, int)
  # True
  
  issubclass(float, int)
  # False
  ```

  

- super()
  - 자식클래스에서 부모클래스를 사용하고 싶은 경우



- 메서드 오버라이딩
  - 상속 받은 메서드를 재정의
    - 상속받은 클래스에서 같은 이름의 메서드로 덮어쓴다
    - 부모 클래스의 메서드를 실행시키고 싶은 경우 super활용



- 다중상속
  - 두개 이상의 클래스를 상속 받는 경우 다중 상속이 됨
    - 상속 받은 모든 클래스의 요소를 활용 가능
    - 중복된 속성이나 메서드가 있는 경우 상속 순서에 의해 결정
