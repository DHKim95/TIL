# Algorithm

### 알고리즘

- 문제를 해결하기 위한 절차
- 알고리즘 표현방법
  - 슈더코드
  - 순서도
- 좋은 알고리즘
  - 정확성
  - 메모리사용
  - 최적화
  - 단순성
  - 작업량
- 시간 복잡도
  - 알고리즘의 작업량 표현
    - 실제 걸리는 시간을 측정
    - 실행되는 명령문 개수 계산
- 빅오 표기법
  - 시간 복잡도 중에서 가장 큰 영향력을 주는 것만 표시



### 배열

- 일정한 자료형의 변수들을 열거하여 사용하는 자료구조
- 필요성
  - 여러개의 변수가 필요할 때 일일이 자료에 접근하는 것은 매우 비효율적이다.
  - 배열은 하나의 선언으로 둘 이상의 변수가 사용가능하다.
  - 배열을 통해 쉽게 작업할 수 있는것이 있다.



### 정렬

- 2개 이상의 자료를 기준에 의해 순서대로 배열하는 것



#### 버블정렬

- 정렬과정

  - 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하며 마지막 자리까지 이동한다.
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

- 시간복잡도

  - O(N^2)

  ```python
  for i in range(len(arr)-1, 0, -1):
      for j in range(0, i):
          if arr[j] > arr[j+1]:
              arr[j], arr[j+1] = arr[j+1], arr[j]
  ```



#### 카운팅 정렬

- 정렬과정

  - 항목들의 순서를 결정하기 위해 항목이 몇개씩 있는지 카운팅 후 선형 시간에 정렬하는 효율적인 알고리즘
  - 정수로 표현할 수 있는 자료에 대해서만 가능하다.
  - 가장 큰 정수를 알아야만 사용할 수 있다.

- 시간복잡도

  - O(N + k)

  ```
  1단계 : 발생횟수를 세어 직접 인덱스 되는 카운트 배열을 저장한다.
  2단계 : 개수를 반영하여 누적 배열을 만들어준다.
  3단계 : 원래 데이터 for문을 돌며 해당 값의 누적인덱스에서 -1을 하며 하나씩 넣어준다.
  ```



#### 완전검색

- 모든 경우의 수를 생성하여 테스트하기 때문에 속도는 느리지만 답을 못찾을 확률은 작다.



#### 탐욕 알고리즘

- 최적해를 구하는데 사용되는 방법
- 순간순간 최적이라고 생각되는 것을 선택해 나아가는 방식
- 각 선택의 시점이 지역적으로 최적이지만 그것이 최적이라는 보장은 없다.

