# Algorithm

### 알고리즘

- 문제를 해결하기 위한 절차
- 알고리즘 표현방법
  - 슈더코드
  - 순서도
- 좋은 알고리즘
  - 정확성
  - 메모리사용
  - 최적화
  - 단순성
  - 작업량
- 시간 복잡도
  - 알고리즘의 작업량 표현
    - 실제 걸리는 시간을 측정
    - 실행되는 명령문 개수 계산
- 빅오 표기법
  - 시간 복잡도 중에서 가장 큰 영향력을 주는 것만 표시



### 정렬

- 2개 이상의 자료를 기준에 의해 순서대로 배열하는 것



#### 버블정렬

- 정렬과정

  - 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하며 마지막 자리까지 이동한다.
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

- 시간복잡도

  - O(N^2)

  ```python
  for i in range(len(arr)-1, 0, -1):
      for j in range(0, i):
          if arr[j] > arr[j+1]:
              arr[j], arr[j+1] = arr[j+1], arr[j]
  ```



#### 카운팅 정렬

- 정렬과정

  - 항목들의 순서를 결정하기 위해 항목이 몇개씩 있는지 카운팅 후 선형 시간에 정렬하는 효율적인 알고리즘
  - 정수로 표현할 수 있는 자료에 대해서만 가능하다.
  - 가장 큰 정수를 알아야만 사용할 수 있다.

- 시간복잡도

  - O(N + k)

  ```
  1단계 : 발생횟수를 세어 직접 인덱스 되는 카운트 배열을 저장한다.
  2단계 : 개수를 반영하여 누적 배열을 만들어준다.
  3단계 : 원래 데이터 for문을 돌며 해당 값의 누적인덱스에서 -1을 하며 하나씩 넣어준다.
  ```



#### 선택정렬

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
- 정렬과정
  - 주어진 리스트 중에서 최소값을 찾는다.
  - 해당 값을 맨 앞과 교환한다.
  - 순차적으로 위 2개를 진행하면서 정렬을 해 나간다.
- 시간복잡도
  - O(N^2)



#### 탐욕 알고리즘

- 최적해를 구하는데 사용되는 방법
- 순간순간 최적이라고 생각되는 것을 선택해 나아가는 방식
- 각 선택의 시점이 지역적으로 최적이지만 그것이 최적이라는 보장은 없다.



#### 셀렉션 알고리즘

- 저장되어 있는 자료부터 k번째로 큰 or 작은 원소를 찾는 방법
  - 최대값 or 최소값 or 중간값을 찾는 알고리즘이다.
- 과정
  - 정렬 알고리즘을 이용하여 자료 정렬
  - 원하는 순서에 있는 원소 가져오기
- 시간복잡도
  - k가 작을 때 매우 유용하다
  - O(kn)



### 배열

- 일정한 자료형의 변수들을 열거하여 사용하는 자료구조
- 필요성
  - 여러개의 변수가 필요할 때 일일이 자료에 접근하는 것은 매우 비효율적이다.
  - 배열은 하나의 선언으로 둘 이상의 변수가 사용가능하다.
  - 배열을 통해 쉽게 작업할 수 있는것이 있다.



#### 2차원 배열

- 1차원 리스트를 묶어놓은 리스트

- 2차원 리스트 : 세로(행), 가로(열)

- 차원에 따라 Index 선언이 가능하다.

- 배열 순회

  - 행 우선 순회

    ```python
    for i in range(len(arr)):
        for j in range(len(arr[i])):
            arr[i][j]
    ```

  - 열 우선 순회

    ```python
    for j in range(len(arr[0])):
        for i in range(len(arr)):
            arr[i][j]
    ```

  - 지그재그 순회

    - 행을 기준으로 홀수와 짝인 경우로 나누어서 지그재그 구현이 가능하다.

- 2차 배열 탐색

  - 델타를 이용한 2차 배열 탐색

    ```python
    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]
    for i in range(len(arr)):
        for j in range(len(arr[i])):
            for k in range(4):
                new_X = x + dx[k]
                new_Y = y + dy[k]
    ```

  - 전치행렬

    ```python
    for i in range(3):
        for j in range(3):
            if i < j:
                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    ```



### 연산자

#### 비트연산자

- & : 비트 단위로 AND연산
- | : 비트 단위로 OR 연산
- << : 연산자의 비트 열을 왼쪽으로 이동시킨다.
- \>> : 연산자의 비트 열을 오른쪽으로 이동시킨다.



### 검색

- 저장되어 있는 자료중에서 원하는 항목을 찾는 방법
- 검색의 종류
  - 순차검색
  - 이진검색
  - 해쉬

#### 완전검색

- 모든 경우의 수를 생성하여 테스트하기 때문에 속도는 느리지만 답을 못찾을 확률은 작다.



#### 순차검색

- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
  - 가장 간단하고 직관적이다.
  - 순차구조에서 원하는 항목을 찾을 때 유용하다.
  - 구현은 쉽지만 검색 수가 많을 경우 비효율적이다.

- 검색과정
  1. 첫번째 원소부터 순서대로 검색 대상과 같은것이 있는지 찾는다.
  2. 동일한 대상을 찾으면 인덱스를 반환한다.
  3. 마지막 까지 찾지 못하면 실패를 반환한다.

#### 이진검색

- 자료의 가운데 있는 항목과 비교하여 다음 검색의 위치를 결정하는 방법
  - 대상을 찾을 때 까지 이진검색을 반복수행함으로서 범위를 반으로 줄여나간다.
  - 반드시 정렬된 상태에서만 이용이 가능하다.
- 검색과정
  1. 중앙에 원소를 고른다.
  2. 목표값을 비교한다.
  3. 목표값이 원소보다 작으면 왼쪽을 탐색 크다면 오른쪽을 탐색한다.
  4. 1~3을 계속 반복하면서 대상을 찾아나간다.
- 구현방법
  - while로도 가능하고 재귀함수로도 가능하다.
