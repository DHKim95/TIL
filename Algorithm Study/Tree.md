# Tree

- 비선형구조
- 1:N 관계를 가지는 자료구조
- 위에서 아래로 내려가는 확장되는 트리 구조

- 나머지 노드들은 하나의 트리가 되며 루트의 부 트리라 한다.

### 구성

![image-20210827090706233](C:\Users\KIMDoHun\AppData\Roaming\Typora\typora-user-images\image-20210827090706233.png)

- 용어
  - 노드 : 트리의 원소
  - 루트 : 최상위 노드
  - 간선 : 노드를 연결하는 선 (부모와 자식을 연결)
  - 형제 노드 : 같은 부모의 자식 노드
  - 조상 노드 : 간선을 따라 루트노드까지 이르는 모든 노드
  - 서브 트리 : 부모와 연결된 간선을 끊었을 때 생성되는 트리
  - 자손 노드 : 서브 트리에 있는 하위레벨 노드
  - 차수 : 노드에 연결된 자식 노드 수
    - B의 차수 = 2, E의 차수 = 1
    - 트리의 차수 : 트리에 있는 노드의 높이 중에서 가장 큰 값 : 3
    - 상대적인 개념이라 0부터 시작도 있고 1부터 시작도 있다.



### 이진트리

- 모든 노드들이 2개의 서브트리를 갖는 특별한 형태 트리
- 자식 노드를 최대 2개 까지만 가질 수 있다.
- 높이가 h면 노드의 최소개수는 h+1이 되며 최대개수는 2**(h+1) - 1 이다.
- 배열을 이용한 이진 트리 표현의 단점
  - 편향 이진 트리인 경우 사용하지 않는 배열 원소에 대해 메모리 공간 낭비 발생
  - 중간에 새로운 노드를 삽입하거나 기존 노드를 삭제할 경우 배열 크기 변경이 어려워 비효율적
  - 단점을 보완하기 위해 연결리스트를 사용하여 구현



#### 포화 이진 트리

- 모든 레벨에 노드가 포화상태로 있는 이진 트리
- 최대 노드 개수를 가진다 ex) 높이가 3이면 15개 노드
- 1 ~ 15번까지 전부 차있다



#### 완전 이진 트리

- 1번부터 n번까지 빈 자리가 없는 이진 트리



#### 편향 이진 트리

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가지는 이진 트리



### 순회

- 트리의 노드들을 체계적으로 방문하는 것
- 각 노드를 중복되지 않게 전부 방문하는데 비 선형 구조기 때문에 선후 연결 관계를 알 수 없다
- 순회방법
  - 전위순회 : 부모노드 방문 후 자식 노드를 좌,우 순서로 방문
  - 중위순회 : 왼쪽노드, 부모노드, 오른쪽노드 순으로 방문
  - 후위순회 : 자식 노드를 좌우 순서로 방문한 후 부모노드 방문



#### 전위순회

- VLR

- 수행방법

  1. 현재 노드 n을 방문 처리

  2. 현재 노드의 왼쪽 서브 트리로 이동

     - 자식이 없으면 3번으로 넘어간다.

  3. 현재 노드의 오른쪽 서브 트리로 이동

     ```python
     def perorder_traversal(arr):
         if arr: # arr가 있으면
             print(arr.item)
             preorder_traversal(arr.left)
             preorder_traversal(arr.right)
     ```



#### 중위순회

- 수행방법

  1. 현재 노드 n의 왼쪽 서브트리로 이동

     - 가장 왼쪽부터 차례로 탐색

  2. 현재 노드 n을 방문 처리

  3. 현재 노드의 오른쪽 서브 트리로 이동

     ```python
     def inorder_traverse(arr):
         if arr:
             inorder_traverse(arr.left)
             print(arr.item)
             inorder_traverse(arr.right)
     ```

     

#### 후위순회

- 수행방법

  1. 현재 노드 n의 왼쪽 서브트리로 이동

  2. 현재 노드 n의 오른쪽 서브트리로 이동

  3. 현재 노드 n을 방문

     ```python
     def postorder_traverse(arr):
         if arr:
             postorder_traverse(arr.left)
             postorder_traverse(arr.right)
             print(arr.item)
     ```

     



힙 - 우선순위가 높은 정점을 찾기위한